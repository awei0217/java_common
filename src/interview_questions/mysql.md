### 1.数据库事务的四个特性及含义
    数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。
    原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过一样。
    一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
    隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。
    持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚

### 2.MYISAM和INNODB的不同？
    a)构造上的区别
     MyISAM在磁盘上存储成三个文件，其中.frm文件存储表定义；.MYD (MYData)为数据文件；.MYI (MYIndex)为索引文件。
     而innodb是由.frm文件、表空间（分为独立表空间或者共享表空间）和日志文件（redo log）组成。
    b)事务上的区别
      myisam不支持事务；而innodb支持事务。
    c)锁上的区别
    myisam使用的是表锁；而innodb使用的行锁（当然innodb也支持表锁）。
    表级锁：直接锁定整张表，在锁定期间，其他进程无法对该表进行写操作，如果设置的是写锁，那么其他进程读也不允许，因此myisam支持的并发量低，但myisam不会出现死锁；
    行级锁：只对指定的行进行锁定，其他进程还是可以对表中的其他行进行操作的。因此行锁能大大的减少数据库操作的冲突，但有时会导致死锁。
    d)是否支持外键的区别
    myisam不支持外键，innodb支持外键
    e) select count(*)的区别
    对于没有where的count(*)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(*)时它直接从计数器中读，而InnoDB必须扫描全表。
    f)myisam只把索引都load到内存中，而innodb存储引擎是把数据和索引都load到内存中
    
### 3.Mysql主从同步原理和流程
    原理：通过binlog复制
    binlog类型
        statement：会将对数据库操作的sql语句写入到binlog中。
        row：会将每一条数据的变化写入到binlog中。
        mixed：statement与row的混合。Mysql决定什么时候写statement格式的，什么时候写row格式的binlog。
    步骤一：主库db的更新事件(update、insert、delete)被写到binlog
    步骤二：从库发起连接，连接到主库
    步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库
    步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log
    步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db

### 4.Innodb是行锁，那什么时候会产生行锁，什么情况下会变成表锁？
    一般情况下，innodb只对指定的行进行锁定，其他进程还是可以对表中的其他行进行操作的，因此，这时候innodb加的就是行锁；
    但是，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”。    

### 5.innodb是如何通过日志实现事务的
    Mysql会最大程度的使用缓存机制来提高数据库的访问效率，但是万一数据库发生断电，因为缓存的数据没有写入磁盘，导致缓存在内存中的数据丢失而导致数据不一致怎么办？
    Innodb主要是通过事务日志实现ACID特性
    事务日志包括：重做日志redo和回滚日志undo
    Redo记录的是已经全部完成的事务，就是执行了commit的事务，记录文件是ib_logfile0 ib_logfile1
    Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）
    一般情况下，mysql在崩溃之后，重启服务，innodb通过回滚日志undo将所有已完成并写入磁盘的未完成事务进行rollback，然后redo中的事务全部重新执行一遍即可恢复数据，但是随着redo的量增加，每次从redo的第一条开始恢复就会浪费长的时间，所以引入了checkpoint机制
     Dirty page：脏页 什么意思呢？
    一般业务运行过程中，当业务需要对某张的某行数据进行修改的时候，innodb会先将该数据从磁盘读取到缓存中去，然后在缓存中对这条数据进行修改，这样缓存中的数据就和磁盘的数据不一致了，这个时候缓存中的数据就称为dirty page，只有当脏页统一刷新到磁盘中才会是clean page
    Checkpoint：如果在某个时间点，脏页的数据被刷新到了磁盘，系统就把这个刷新的时间点记录到redo log的结尾位置，在进行恢复数据的时候，checkpoint时间点之前的数据就不需要进行恢复了，可以缩短时间
    Innodb_log_buffer_size 重做日志缓存大小
    Innodb_log_file_size redo log文件大小  文件越大 数据恢复的时间越长
    Innodb_log_file_group redo log文件数量 默认是2个 ib_logfile0 ib_logfile1
   
### 6.mysql聚簇索引和非聚簇索引
    聚簇索引并不是一种单独的索引类型，而是一种数据存储方式
    聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。聚簇索引要比非聚簇索引查询效率高很多。
    聚集索引这种主+辅索引的好处是，当发生数据行移动或者页分裂时，辅助索引树不需要更新，因为辅助索引树存储的是主索引的主键关键字，而不是数据具体的物理地址。
    MyISAM的是非聚簇索引，B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。这里的索引都是非聚簇索引。非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，
    这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，这是聚簇索引。聚簇索引，叶子节点上的data是主键(所以聚簇索引的key，不能过长)。
    InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。

### 7.数据库中乐观锁和悲观锁
    ** 乐观 悲观 锁 主要是作用在并发访问控制**
    悲观锁 假定会发生并发冲突，屏蔽任何违反数据完整的操作
    乐观锁 假定不会发生冲突，只有在提交操作时检查是否违反数据的完整性
    
### 8.什么场景下适合创建索引，什么场景下不适合创建索引。？ 
    where，order by，group by中频繁出现，且数据分布比较离散的列适合创建索引。比如有个用户表，用户名，手机号经常会作为查询条件，且不同用户用户名，手机号都不同（数据较离散），因此适合创建索引。但是用户的性别，虽然也会经常作为查询条件，但是因为性别只有男，女，未知等几种，数据不够离散，因此不适合创建索引。为什么要离散？ 
    频繁修改的列不适合创建索引。mysql索引基于B+树实现，修改数据时，需要修改对应的索引。
    
### 9.联合索引命中规则？
    联合索引命中规则为最左匹配原则（mysql索引基于B+树实现）。 
    假设A,B,C三列创建了联合索引， 
    能命中索引的
    where A=xx
    where A=xx and B=xx
    where A=xx and B=xx and C=xx
    不能命中索引的
    where B=xx
    where C=xx
    where B=xx and C=xx
### 10.索引命中规则 
        假设A列创建了索引 
        能命中的
        <，<=，=，>，>=，BETWEEN，IN, like 'xx%'
        不能命中的
        <>，not in ，!=，like '%xx'
        字符串转数字. 比如mobile varchar(11)
         where mobile=131xxxxxxxx
        对列进行函数运算的情况
        where md5(password) =' xxxx'
   
### 11.覆盖索引         
    覆盖索引：一个索引包含所有要查询的字段的值。
    优点：
    ①：索引条目通常远小于数据行，因此如果只读取索引，可以极大的减小数据访问量，同样索引也更容易放入内存，所以对于I/O密集型的应用有很大帮助。
    ②：索引是按照列顺序存储的。
    ③：有的存储引擎如MyIsam只在内存中缓存索引，数据依赖于操作系统缓存，因此覆盖索引避免了频繁的系统调用。
    覆盖索引必须要存储索引列的值，而哈希索引，空间索引和全文索引都不存储索引列的值，所以覆盖索引必须使用B-Tree索引

### explain 中的 Extra字段的值的含义
    using index ：使用覆盖索引的时候就会出现
    using where：在查找使用索引的情况下，需要回表去查询所需的数据
    using index condition：查找使用了索引，但是需要回表查询数据 
    Using filesort 在使用order by关键字的时候，如果待排序的内容不能由所使用的索引直接完成排序的话，那么mysql有可能就要进行文件排序
    
### MySQL orde by原理
    https://blog.csdn.net/hguisu/article/details/7161981
 
    