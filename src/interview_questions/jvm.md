### jvm配置参数详解
    针对JDK1.8 
           -Xms4G 堆内存最小值
           -Xmx4G 堆内存最大值 
           -Xss1024K   线程的栈大小 jdk1.5以上默认为1M
           -XX SurvivorRatio=8  年轻代中 EdenSpace 和 单个Survivor区的比例为 8:1
           -XX NewRatio=2 年轻代和年老代的比例 2:1 Young:Old = 2:1
           -XX:MetaspaceSize=1024m    这参数使用的本地内存（也就是堆外内存） 这个空间主要来存放Class和Meta的信息，如果应用程序需要加载很多class文件，当这块内存不够时，会报OOM
           这个参数是初始化的Metaspace大小，该值越大触发Metaspace GC的时机就越晚。随着GC的到来，虚拟机会根据实际情况调控Metaspace的大小。
           -XX:MaxMetaspaceSize=1024m  最大空间，默认是没有限制的。
           -XX:MinMetaspaceFreeRatio=5 在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 
           -XX:MaxMetaspaceFreeRatio=5 在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集
           
           
### jdk8为什么移除持久代
    它的大小是在启动时固定好的——很难进行调优。-XX:MaxPermSize，设置成多少好呢？
    HotSpot的内部类型也是Java对象：它可能会在Full GC中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。
    简化Full GC：每一个回收器有专门的元数据迭代器。
    可以在GC不进行暂停的情况下并发地释放类数据。
    使得原来受限于持久代的一些改进未来有可能实现  
    根据上面的各种原因，永久代最终被移除，方法区移至Metaspace，字符串常量移至Java Heap
    
### 元空间的特点
    充分利用了Java语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。
    每个加载器有专门的存储空间
    只进行线性分配
    不会单独回收某个类
    省掉了GC扫描及压缩的时间
    元空间里的对象的位置是固定的
    如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉    
    
### G1和Parallel GC的区别
    G1是一个低延迟垃圾回收器，对于应用的整体用户体验来讲，低延迟的收集器要好于高吞吐的收集器，故将G1置为默认收集器，在Java 7/8中的默认收集器是面对高吞吐的Parallel GC    
    低延尽代表着响应能力，在架构设计要求中常常可以看到响应能力和吞吐量两个指标经常是成对出现。一般来讲，我们对Java应用进行优化主要也是针对这两个指标。
    响应能力是指应用或者系统在多快能够返回请求的数据，比如说点击一个按钮多快有反应，多快能够打开一个网页或者多快能够返回一次数据库查询等。对于面对响应能力的应用来说，长时间的停顿是不可接受的。
    吞吐量专注于在某个时间段内能够处理最大工作负载，比如说每分钟处理多个少事务，每分钟完成了多少个任务或者每分钟完成了多少个数据库查询。对于面对吞吐量的应用来讲，较长的停顿时间是能够接受的，高吞吐量应用关注的是系统处理能力，单个事务，任务或者查询的响应速度不是它的考虑

### G1的优点
    G1 收集器是一个面向服务器模式的垃圾收集器，主要为多CPU机器和大内存机器设计。它可以尽可能在达到高吞吐量同时满足垃圾收集暂停时间目标。G1 有以下几个优点：
    1. 能够像CMS收集器一样跟应用线程并行操作
    2. 收缩空闲空间不会造成由长GC引起的应用停顿时间。
    3. 更精确的预测GC停顿时间
    4. 不会牺牲太多的吞吐效率
    5. 不请求较多的Java堆
