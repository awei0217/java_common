数据同步需要依赖锁，那锁的同步又依赖谁？synchronized给出的答案是在软件层面依赖JVM，而Lock给出的方案是在硬件层面依赖特殊的CPU指令。


锁的细分：

    1、自旋锁
        自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区

    2、阻塞锁
        可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，
        进入运行状态。
        JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字（其中的重量锁），
        ReentrantLock，Object.wait()\notify(),LockSupport.park()/unpart()(j.u.c经常使用)

    3、可重入锁
        可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。
        在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁

    4、读写锁
        假设你的程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁。在没有写操作的时候，两个线程同时读一个资源没有任何问题，
        所以应该允许多个线程能在同时读取共享资源。但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写。
        （也就是说：读-读能共存，读-写不能共存，写-写不能共存）。这就需要一个读/写锁来解决这个问题。
        ReentrantReadWriteLock

    5、互斥锁
        所谓互斥锁, 指的是一次最多只能有一个线程持有的锁

    6、悲观锁
        悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。
        传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
        再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。

    7、乐观锁
        顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，
        可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，
        其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

    8、公平锁
    9、非公平锁

    10、偏向锁
        偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。
        如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁
        http://blog.csdn.net/u014411966/article/details/51347100

    11、对象锁

    12、线程锁

    13、锁粗化
        锁粗化，如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展到整个操作序列的外部，这样就只需要加锁一次就够了。

    14、锁消除
        锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除主要判定依据来源于逃逸分析的数据支持

    15、轻量级锁

    16、锁膨胀
        偏向锁---->轻量级锁----->重量级锁

    17、信号量
        Semaphore


锁的粗分：
    在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，

    无锁：

    偏向锁：加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。         如果线程间存在锁竞争，会带来额外的锁撤销的消耗。           如果线程间存在锁竞争，会带来额外的锁撤销的消耗。

    轻量级锁：竞争的线程不会阻塞，提高了程序的响应速度。         如果始终得不到锁竞争的线程使用自旋会消耗CPU。                追求响应时间，同步块执行速度非常快。

    重量级锁：线程竞争不使用自旋，不会消耗CPU。              线程竞争不使用自旋，不会消耗CPU。        追求吞吐量， 同步块执行速度较长。

